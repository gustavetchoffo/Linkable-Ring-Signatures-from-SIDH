# SageMath (2, 2)-isogenies in the Theta Model 

This library implements $(2, 2)$-isogenies in the theta model, with the practical application to efficiently compute chains of isogenies between elliptic products.

### Usage

To compute a $(2^n, 2^n)$-isogeny between elliptic products, computing the codomain and evaluation follows the same form as dimension one isogenies in SageMath:
```python
from theta_structures.couple_point import CouplePoint
from theta_isogenies.product_isogeny import EllipticProductIsogeny, EllipticProductIsogenySqrt

# The input to the function is user generated
# The requirement is two pairs of points on the elliptic product E1 x E2
# and `n`, the length of the isogeny chain
from user_data import P1, P2, Q1, Q2, n

# The kernel is generated by two pairs of points on
# the domain P, Q in E1 x E2
# The kernel is expected to be of type (CouplePoint, CouplePoint)
P, Q = CouplePoint(P1, P2), CouplePoint(Q1, Q2)
kernel = (P, Q)

# Compute isogeny Phi: E1 x E2 -> E3 x E4 of length n
Phi = EllipticProductIsogenySqrt(kernel, n)

# If we have points P1b, P2b, Q1b, Q2b of 2^{n+2}-torsion above P1, P2, Q1, Q2,
# which means that P1=4*P1b, P2=4*P2b, Q1=4*Q1b, Q2=4*Q2b,
# we can use them to speed up the isogeny computation
Pb, Qb = CouplePoint(P1b, P2b), CouplePoint(Q1b, Q2b)
kernelb = (Pb, Qb)
Phi = EllipticProductIsogeny(kernelb, n)

# Codomain is computed as the isogeny object is constructed 
E3, E4 = Phi.codomain()

# Evaluating the isogeny is done by calling Phi on a CouplePoint
img_P = Phi(P)
```

### Worked Example

As a concrete example, take $p = 2^{11} \cdot 3^5 - 1$ and consider the isogeny $\Phi : E_1 \times E_2 \to E_3 \times E_4$. We take points $P_1$, $P_2$, $Q_1$, $Q_2$
of order $2^{n + 2}$ for $n = 9$ which when taken as a kernel $\langle (P_1, P_2), (Q_1, Q_2) \rangle$
generates an isogeny of degree $(2^n, 2^n)$-between elliptic products.

**Note**: the explicit data below has been constructed from `isogeny_diamond.py`, and can be dynamically generated from `generate_splitting_kernel()` for further examples.

```python
from theta_structures.couple_point import CouplePoint
from theta_isogenies.product_isogeny import EllipticProductIsogeny

p = 2^11 * 3^5 - 1
F.<i> = GF(p^2, modulus=x^2 + 1)

A1 = F(0)
A2 = 449036*i+188759
E1 = EllipticCurve(F, [0, A1, 0, 1, 0]) # Curves are in the Montgomery model
E2 = EllipticCurve(F, [0, A2, 0, 1, 0])

# We will compute an isogeny chain of length 9
n = 9

# Points for the kernel of order 2^(n+2)
P1 = E1(138723*i + 470725, 162964*i + 196611)
Q1 = E1(396887*i + 62562, 217757*i + 426655)
P2 = E2(327760*i + 400225, 232691*i + 398962)
Q2 = E2(430142*i + 266365, 308374*i + 232855)

# Construct the kernel into the expected type
P, Q = CouplePoint(P1, P2), CouplePoint(Q1, Q2)
kernel = (P, Q)

# Compute isogeny Phi: E1 x E2 -> E3 x E4 of length n
Phi = EllipticProductIsogeny(kernel, n)
print(Phi.codomain()[0])
print(Phi.codomain()[1])
# Output:
#
# Elliptic Curve defined by y^2 = x^3 + (189648*i+350544)*x^2 + x over Finite Field in i of size 497663^2
# Elliptic Curve defined by y^2 = x^3 + x over Finite Field in i of size 497663^2

# Evaluate a point on E1 x E2 under the action of Phi
R1 = E1(0)
R2 = E2(476711*i + 497008, 316369*i + 137958)
R = CouplePoint(R1, R2)
print(Phi(R))
# Output:
#
# [(145212*i + 486924 : 68908*i + 135992 : 1), (427043*i + 16946 : 474919*i + 326000 : 1)]
```

#### When Additional Torsion is not Available

For the above example, we are in the optimal case when we are able to have points with order $2^{n + 2}$, allowing the chain to computed efficiently.
If we are only able to obtain the points of order $2^n$ which generate the isogeny, then the final two steps require some square roots to compute the codomain. For this case, the isogeny between products can be computed from `EllipticProductIsogenySqrt()`.

```python
from theta_structures.couple_point import CouplePoint
from theta_isogenies.product_isogeny_sqrt import EllipticProductIsogenySqrt

p = 2^11 * 3^5 - 1
F.<i> = GF(p^2, modulus=x^2 + 1)

A1 = F(0)
A2 = 129143*i + 235488
E1 = EllipticCurve(F, [0, A1, 0, 1, 0]) # Curves are in the Montgomery model
E2 = EllipticCurve(F, [0, A2, 0, 1, 0])

# We will compute an isogeny chain of length 11
n = 11

# Points for the kernel of order 2^n
P1 = E1(67757*i + 198628, 239152*i + 223924)
Q1 = E1(310218*i + 204034, 415411*i + 261911)
P2 = E2(59303*i + 471250, 86033*i + 368242)
Q2 = E2(481566*i + 29262, 313474*i + 465594)

# Construct the kernel into the expected type
P, Q = CouplePoint(P1, P2), CouplePoint(Q1, Q2)
kernel = (P, Q)

# Compute isogeny Phi: E1 x E2 -> E3 x E4 of length n
Phi = EllipticProductIsogenySqrt(kernel, n)
print(Phi.codomain()[0])
print(Phi.codomain()[1])
# Output
#
# Elliptic Curve defined by y^2 = x^3 + 256695*x^2 + x over Finite Field in i of size 497663^2
# Elliptic Curve defined by y^2 = x^3 + (375999*i+496857)*x^2 + x over Finite Field in i of size 497663^2

# Evaluate a point on E1 x E2 under the action of Phi
R1 = E1(0)
R2 = E2(200895*i + 209766,  438792*i + 485262)
R = CouplePoint(R1, R2)
print(Phi(R))
# Output
#
# [(183354*i + 293598 : 39951*i + 50538 : 1),(360797*i + 349277 : 44693*i + 388934 : 1)]
```

### Project Overview

The code for this project is split into separate sub-modules to allow only what is needed to be copied to various projects.

#### Main Contribution

- `theta_structures/` contains classes which represent `ThetaPoint` and the parent `ThetaStructure`, which are the main objects encountered during the isogeny chain. Additionally, there is a class for `CouplePoint`, which is an element on the elliptic product $E_1 \times E_2$, as well as `ProductThetaStructure` and `SplitThetaStructure` which are child classes of `ThetaStructure` and handle the additional isomorphisms needed to ensure everything is of the correct form during the isogeny chain.

- `theta_isogenies/` contains isogenies (and isomorphisms) required during the computations of the isogeny chains. The product isogeny itself `EllipticProductIsogeny` and the alternative chain which uses square-roots rather than the 8-torsion for the final steps is available from `EllipticProductIsogenySqrt`. Each individual $(2,2)$-isogeny step is its own `ThetaIsogeny`. The special case of the gluing isogeny is `GluingThetaIsogeny` and does both the basis change to ensure the compatible structure as well as the
special $(2,2)$-isogeny and evaluation as described in the paper. Finally the splitting isomorphism from a product theta structure to a pair of elliptic curves is handled by `SplittingIsomorphism`. 

#### Utilities

Many other useful functions are relegated to the utilities submodule. Some of these are used only for dimension one computations which are required to generate the data, such as `supersingular.py` and `order.py`. Other functions, such as those in `polynomial_inversion.py` are only used for the Richelot isogeny chain which is used for comparison. The file `fast_sqrt.py` implements a fast method to compute square roots in $\mathbb{F}_{p^2}$ using that $p = 3\mod 4$. Maybe of most interest is `optimised_strategy()`, which computes an optimal strategy for the $(2, 2)$-isogeny chain, taking into account that gluing images have a different cost to that of all other steps.

#### Auxiliary files

- `montgomery_isogenies/` is a port of [KummerIsogeny](https://github.com/GiacomoPope/KummerIsogeny) by Giacomo Pope and computes dimension one isogenies between elliptic curves using the efficient $x$-only formula in the Montgomery model. Only used for the construction of isogeny diamonds for testing and examples
- `richelot_isogenies/` is a port of the $(2, 2)$-isogenies from the [Castryck-Decru-SageMath](https://github.com/GiacomoPope/Castryck-Decru-SageMath) with the additional optimisations included for the proof-of-concept code for [FESTA-SageMath](https://github.com/FESTA-PKE/FESTA-SageMath).
- `isogeny_diamond.py`: this code efficiently generates kernels used to compute isogenies between elliptic products. Sets up a starting curve $E_0$ with small endomorphism ring and a characteristic so that an auxiliary isogeny can be written as the sum of two squares.

#### Benchmarks and Tests

Benchmark and test files are located in `benchmarks/` and  `tests/` respectively. They are only included for those who wish to benchmark the running times of the various isogenies on different hardware, or test various modifications of the algorithms in the future.
