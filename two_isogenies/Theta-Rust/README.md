# Constant Time (2, 2)-isogenies in the Theta Model 

This library implements $(2, 2)$-isogenies in the theta model for the purpose of cryptographic research. The current implementation focuses on an efficient and constant time implementation of a $(2^n, 2^n)$-isogeny between elliptic products, with the aim of improving the performance of isogeny-based primitives, such as FESTA[^1].

[^1]: https://eprint.iacr.org/2023/660

### Project Overview

The following section gives an overview of the types implemented for the computation of an isogeny between elliptic products. 

#### Finite Field Arithmetic

Underlying all the other parts of the code is the constant-time implementation of finite field arithmetic in $\mathbb{F}\_{p^2}$, written in most part by Thomas Pornin from ongoing work in another project. Much of the macro for both  $\mathbb{F}\_{p}$ and $\mathbb{F}\_{p^2}$ has been adapted from the [`crrl` Rust library](https://github.com/pornin/crrl).

To create a finite field with modulus $p$, the macro `define_fp_core` expects several constants, which can be computed using the sage script `gen_fp.sage`. The field $\mathbb{F}\_{p^2}$ is built on top of this macro and assumes that $p = 3 \mod 4$ such that the modulus of the extension field is $x^2 + 1 = 0$. The construction of the extension is a separate macro and takes as argument the type representing $\mathbb{F}\_{p}$.
To see an example of the creation of these fields see `fields.rs`.

Note that the arithmetic makes very few assumptions on the modulus itself. This means that our code should be portable for many use cases, but it also means there are further optimisations which could be implemented at the level of the field arithmetic which could save cycles when performance is of the utmost importance. 

#### Elliptic Curves

Following the pattern of code re-use, `eccore.rs` is another macro `define_ec_core` written in collaboration with Thomas Pornin from previous work, and includes both the `Curve` and `Point` types needed for the dimension one computations which are done either before the gluing isogeny or after the splitting isomorphism.

The `Curve` type assumes the elliptic curve is in the Montgomery mode. The `Point` type is simply a `struct` of base-field elements and functions to perform arithmetic (such as doubling) are tied to the `Curve` type. As an example, point doubling is implemented as `E.double(P)` where `E` is of type `Curve` and `P` of type `Point`.

On top of the previous work, additional `CouplePoint` and `EllipticProduct` types have been implemented, which are essentially used for bookkeeping and can be thought of as tuples of types: `(Point, Point)` and `(Curve, Curve)`.

#### Theta Structures

Two types are needed at the level of theta structures. The `ThetaPoint` type is simply a `struct` of four field elements. `ThetaStructure` can be considered the parent of this type (as `Curve` is to `Point`) and is a `struct` which is defined by the null point (of type `ThetaPoint`) as well as a collection of six field elements computed on creation which are used to lower the cost of both doubling and isogeny computation. 

#### Theta Isogenies

The isogeny between elliptic products is computed by the function

```rust
pub fn product_isogeny(
    E1E2: &EllipticProduct,
    P1P2: &CouplePoint,
    Q1Q2: &CouplePoint,
    image_points: &[CouplePoint],
    n: usize,
    strategy: &[usize],
) -> (EllipticProduct, Vec<CouplePoint>) {
```

Which takes the domain of the isogeny, the elliptic product $E\_1 \times E\_2$, along with the kernel generated by two `CouplePoints` and a slice `image_points` which contains all points a user wishes to evaluate under the action of the isogeny. The array, `strategy`, is precomputed from `strategy.py` and uses costings computed from the benchmark `msi.rs` which computes the relative costs of multiplications, squarings and inversions in the base field. 

The `product_isogeny` function has been implemented to be constant time, and is built with many sub-functions. The code has been written with a hope to be readable, with many comments, and we hope that the workings of this library are evident in the way the code is laid out.

### Examples and Benchmarks

The main routine of this library shows examples of a $(2^n, 2^n)$-isogeny between elliptic products for three distinct base fields. If you wish to run an isogeny on your machine, then you only need to run in the root of this directory the following command:

```bash
cargo run
```

As an example of how the code looks to compute an isogeny, we include here the chain of length 126 over a 254-bit charactertisc base field. Note that many of the lines below are simply in the conversion of data extracted for SageMath and would be unnecessary when writing a rust implementation of an entire protocol.

```rust
use theta_rs::theta254::{product_isogeny, CouplePoint, Curve, EllipticProduct, Fq, Point};

println!("Testing chain for 254-bit parameters");

// Curve coefficients
let A1 = Fq::ZERO;
let A2_str = "2687f041b47d1ea9c00ae938b2a761aac6bad9ea80dd9dbe1c24d9ef697d7d0475898661998dd3a7b186e2558d1cf0dd771fb49483988c2ff578547815e8f00e";
let (A2, _) = Fq::decode(&hex::decode(A2_str).unwrap());

// Kernel Data
let P1_X_str = "63385515142ea2f7a0c3747c22668aef99b31f43987354116da1915c24ff2f0a279051962feace976834986fc955b11bb8e1ffea47d8ce994ad22ee86c7f7a00";
let P1_Y_str = "38243631804d307b72ecd037da591d1f06ca606bf1bb71d77ce10467b00f7b082472068bfea9eb9d80b68e04bb194a23e5214ba41625915d8e590024e5dcf611";
let P2_X_str = "3e218d8b18cf09ce29cefaa35467225134910411fe33625136e50f7b9c59e51c517629d8786a98603cc06470a10dea83f7eca03b9b378297c21755bf0aee1324";
let P2_Y_str = "06d56830cea82c91cf4059078566145d4b90d992177916ffe1380060057d75277610f27fc5558e5d028699493a300d84521f0c077c6e52c6adc1820c8f53f11a";
let Q1_X_str = "3b569c320301eb5aa1aa078b7399d31e2e0e6c70e91223d1d3346be7145c100b16e4c042048452157133174122c04b1c9a17f38c28e959828933a95eebf6a305";
let Q1_Y_str = "04a2a994555e67a3ddbb5f87dbef7903a9fc9724cb36e51924d28522222c3d2bd07a4d44b06b176b63d78733a1a4839606276b8c523bd6dc8f23de01e2817e17";
let Q2_X_str = "4076f17bf841c5d6acc194e75a4cd020fe3ea03b0914cf3f3db9cc882f8b4724a18ce4bb13c2b3c46abd8e6cdb502dd7f48e58ee49d6c1d632532f6ed995e12b";
let Q2_Y_str = "5b88c588b1f27496800acbef34817c5fa5cbcd728de00e31a46fc7aa6ef9af0e173d1ba96e1b2c2ebc5bc3dd3f980344b508b9df1863fb624855dc1a8cc17b12";
let (P1_X, _) = Fq::decode(&hex::decode(P1_X_str).unwrap());
let (P1_Y, _) = Fq::decode(&hex::decode(P1_Y_str).unwrap());
let (P2_X, _) = Fq::decode(&hex::decode(P2_X_str).unwrap());
let (P2_Y, _) = Fq::decode(&hex::decode(P2_Y_str).unwrap());
let (Q1_X, _) = Fq::decode(&hex::decode(Q1_X_str).unwrap());
let (Q1_Y, _) = Fq::decode(&hex::decode(Q1_Y_str).unwrap());
let (Q2_X, _) = Fq::decode(&hex::decode(Q2_X_str).unwrap());
let (Q2_Y, _) = Fq::decode(&hex::decode(Q2_Y_str).unwrap());

// Curves which define elliptic product
let E1 = Curve::new(&A1);
let E2 = Curve::new(&A2);
let E1E2 = EllipticProduct::new(&E1, &E2);

// Points on E1 x E2
let P1 = Point::new_xy(&P1_X, &P1_Y);
let P2 = Point::new_xy(&P2_X, &P2_Y);
let Q1 = Point::new_xy(&Q1_X, &Q1_Y);
let Q2 = Point::new_xy(&Q2_X, &Q2_Y);
let P1P2 = CouplePoint::new(&P1, &P2);
let Q1Q2 = CouplePoint::new(&Q1, &Q2);

// To save space, we do not encode points to push through the isogeny in this example
let image_points = [];

// Length of isogeny chain
let n = 126;

// Strategy computed from strategy.py
let strategy: [usize; 125] = [
    55, 34, 21, 15, 5, 3, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 8, 5, 3, 2, 1, 1, 1, 1, 1, 2, 1,
    1, 1, 3, 2, 1, 1, 1, 1, 1, 13, 8, 5, 3, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 3, 2, 1, 1, 1, 1, 1,
    5, 3, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 21, 13, 8, 5, 3, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 3, 2, 1,
    1, 1, 1, 1, 5, 3, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 8, 5, 3, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 3,
    2, 1, 1, 1, 1, 1,
];

// Compute chain
let (E3E4, images) = product_isogeny(&E1E2, &P1P2, &Q1Q2, &image_points, n, &strategy);
```

To benchmark the computational times of the isogenies between elliptic products as described in Table 5.1 of the paper, run the following command:

```bash
RUSTFLAGS="-C target-cpu=native" cargo bench
```

Here the optional flag `target-cpu=native` has been set to make the most of the CPU specific opcodes (this research was compiled and run on an x86 CPU and `xmul` offers a nice speed up for the field arithmetic.)

By default the following three isogenies are benchmarked:

- An isogeny chain of length **126** over the base field $\mathbb{F}_{p^2}$ with a **254** bit characteristic 
- An isogeny chain of length **208** over the base field $\mathbb{F}_{p^2}$ with a **381** bit characteristic 
- An isogeny chain of length **632** over the base field $\mathbb{F}_{p^2}$ with a **1293** bit characteristic 

For more (or less) benchmarks to be run, please edit the `cargo.toml` file or to select a particular benchmark the following command can be run

```bash
RUSTFLAGS="-C target-cpu=native" cargo bench --bench isogeny_chain
```

which will benchmark the middle of the three examples.
